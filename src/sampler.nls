;; Portfolio sampler and metrics

;; Returns the fractional eligible coverage for a cell type.
;; general_analysis.nlogo exposes separate sliders for roof and ground;
;; older models set both to pct_covered_by_NBS_RES in their setup procedure.
to-report coverage-of-type [ctyp]
  ifelse ctyp = "roof"
    [ report pct_covered_roof / 100 ]
    [ report pct_covered_ground / 100 ]
end

to init-portfolio-sampler
  set blocks-ordered sort table:keys id-table
  let counts []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    if (length opts = 0) [
      user-message (word "No available options for cell type '" ctype "' after applying max_pct_RES=" max_pct_RES "% and max_pct_NBS=" max_pct_NBS "% constraints. Adjust sliders and run setup again.")
      stop
    ]
    set counts lput (length opts) counts
  ]
  set max-portfolios product-of counts
  set visited-portfolios table:make
  set initialized? true
  set combo-index 0
  print (word "Sampler ready. Max portfolios (upper bound): " max-portfolios)
end

to-report sample-portfolio
  let result []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    let choice one-of opts
    set result lput (list bid choice) result
  ]
  report result
end

to-report portfolio-key [portfolio]
  let parts []
  foreach portfolio [ p ->
    let bid   item 0 p
    let opt   item 1 p
    let resv  item 0 opt
    let nbsv  item 1 opt
    ;; use percentages rounded to 2 decimals for key stability
    set parts lput (word bid ":" (precision (resv * 100) 2) ":" (precision (nbsv * 100) 2)) parts
  ]
  set parts sort parts
  report join-with parts "|"
end

to-report compute-portfolio-totals [portfolio]
  ;; Accumulate physical quantities first; apply portfolio-level discount to cost at the end.
  let total-res-area 0
  let total-res-units 0
  let total-trees    0
  let total-co2      0
  foreach portfolio [ p ->
    let bid item 0 p
    let opt item 1 p
    let res item 0 opt
    let nbs item 1 opt

    let rec table:get id-table bid
    let area item 0 rec
    let ctyp item 1 rec

    ;; RES contributions (per m2) — coverage depends on cell type (roof vs ground)
    let cov (coverage-of-type ctyp)
    let res_area (area * cov * res)
    let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
    let res_co2_m2  item 1 resI
    let res_co2_total  (res_area * res_co2_m2)

    ;; NBS contributions (per tree) with coverage cap
    let eff_nbs_area (area * cov * nbs)
    let trees (ifelse-value (tree_cover_area > 0)
                 [ floor (eff_nbs_area / tree_cover_area) ]
                 [ 0 ])
    ;; Roof load cap: trees <= floor(eff_nbs_area * max_roof_load / tree_weight)
    if (ctyp = "roof") [
      if (tree_weight > 0) [
        let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
        if trees > load_cap [ set trees load_cap ]
      ]
    ]
    let nbs_co2_total  (trees * co2_reduction_NBS)

    set total-res-area total-res-area + res_area
    if (res_cell_area > 0) [ set total-res-units total-res-units + floor (res_area / res_cell_area) ]
    set total-trees    total-trees    + trees
    set total-co2      total-co2      + res_co2_total + nbs_co2_total
  ]
  ;; Apply portfolio-level economies-of-scale discount to total cost.
  ;; RES cost uses continuous area (consistent with per-block table); phi uses integer units.
  let gR (ifelse-value (is-number? res_cost_floor) [ res_cost_floor ] [ 1.0 ])
  let NR (ifelse-value ((is-number? res_discount_units) and (res_discount_units > 0)) [ res_discount_units ] [ 1e30 ])
  let phiR min (list (total-res-units / NR) 1)
  let gN (ifelse-value (is-number? nbs_cost_floor) [ nbs_cost_floor ] [ 1.0 ])
  let NN (ifelse-value ((is-number? nbs_discount_units) and (nbs_discount_units > 0)) [ nbs_discount_units ] [ 1e30 ])
  let phiN min (list (total-trees / NN) 1)
  let total-cost ((total-res-area * cost_RES * (1 - (1 - gR) * phiR)) + (cost_NBS * total-trees * (1 - (1 - gN) * phiN)))
  report (list total-cost total-co2)
end

;; -------- Deterministic enumeration --------

to-report portfolio-from-index [idx]
  ;; Mixed-radix enumeration over blocks-ordered
  let result []
  let i idx
  foreach blocks-ordered [ bid ->
    let rec   table:get id-table bid
    let ctype item 1 rec
    let opts  table:get options-by-type ctype
    let n     length opts
    let digit i mod n
    set i floor (i / n)
    let choice item digit opts
    set result lput (list bid choice) result
  ]
  report result
end

;; -------- Monitors helpers (reporters by bid) --------

to-report mix-for [bid]
  if (last-portfolio = [] or last-portfolio = nobody) [ report nobody ]
  let found nobody
  foreach last-portfolio [ p ->
    if (item 0 p) = bid [ set found (item 1 p) ]
  ]
  report found  ;; [res nbs label] or nobody
end

to-report area-of [bid]
  if not table:has-key? id-table bid [ report 0 ]
  report item 0 (table:get id-table bid)
end

to-report celltype-of [bid]
  if not table:has-key? id-table bid [ report "" ]
  report item 1 (table:get id-table bid)
end

to-report res-pct-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  report (item 0 m) * 100
end

to-report nbs-pct-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  report (item 1 m) * 100
end

to-report res-area-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  let ctyp celltype-of bid
  report (area-of bid) * (coverage-of-type ctyp) * (item 0 m)
end

to-report trees-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  let area area-of bid
  let ctyp celltype-of bid
  let nbs  item 1 m
  let eff_nbs_area (area * (coverage-of-type ctyp) * nbs)
  let trees (ifelse-value (tree_cover_area > 0) [ floor (eff_nbs_area / tree_cover_area) ] [ 0 ])
  if (ctyp = "roof") [
    if (tree_weight > 0) [
      let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
      if trees > load_cap [ set trees load_cap ]
    ]
  ]
  report trees
end

;; -------- Portfolio-wide totals and "any" reporters --------

;; Totals based on the current selected portfolio (rows used in the table)
to-report total-area-current
  if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
  let total 0
  foreach last-portfolio [ p ->
    let bid item 0 p
    set total total + area-of bid
  ]
  report total
end

to-report total-res-area-current
  if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
  let total 0
  foreach last-portfolio [ p ->
    let bid item 0 p
    let m mix-for bid
    if m != nobody [
      let area area-of bid
      let ctyp celltype-of bid
      let res  item 0 m
      let cov (coverage-of-type ctyp)
      set total total + (area * cov * res)
    ]
  ]
  report total
end

to-report total-trees-current
  if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
  let total 0
  foreach last-portfolio [ p ->
    let bid item 0 p
    set total total + trees-of bid
  ]
  report total
end

to-report avg-res-pct
  ;; Average of per-block RES% for the current portfolio rows
  if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
  let n 0
  let s 0
  foreach last-portfolio [ p ->
    let bid item 0 p
    let m mix-for bid
    if m != nobody [
      set s s + ((item 0 m) * 100)
      set n n + 1
    ]
  ]
  if n = 0 [ report 0 ]
  report (s / n)
end

to-report avg-nbs-pct
  ;; Average of per-block NBS% for the current portfolio rows
  if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
  let n 0
  let s 0
  foreach last-portfolio [ p ->
    let bid item 0 p
    let m mix-for bid
    if m != nobody [
      set s s + ((item 1 m) * 100)
      set n n + 1
    ]
  ]
  if n = 0 [ report 0 ]
  report (s / n)
end

to-report area-of-any [key]
  if key = "Total" [ report total-area-current ]
  report area-of key
end

to-report trees-of-any [key]
  if key = "Total" [ report total-trees-current ]
  report trees-of key
end

to-report res-area-of-any [key]
  if key = "Total" [ report total-res-area-current ]
  report res-area-of key
end

to-report res-pct-of-any [key]
  if key = "Total" [ report avg-res-pct ]
  report res-pct-of key
end

to-report nbs-pct-of-any [key]
  if key = "Total" [ report avg-nbs-pct ]
  report nbs-pct-of key
end

to-report cost-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  let rec  table:get id-table bid
  let area item 0 rec
  let ctyp item 1 rec
  let res  item 0 m
  let nbs  item 1 m
  let cov (coverage-of-type ctyp)
  ;; RES
  let res_area (area * cov * res)
  let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
  let res_cost_m2 item 0 resI
  let res_cost (res_area * res_cost_m2)
  ;; NBS
  let eff_nbs_area (area * cov * nbs)
  let trees (ifelse-value (tree_cover_area > 0)
               [ floor (eff_nbs_area / tree_cover_area) ]
               [ 0 ])
  if (ctyp = "roof") [
    if (tree_weight > 0) [
      let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
      if trees > load_cap [ set trees load_cap ]
    ]
  ]
  let nbs_cost (trees * cost_NBS)
  report (res_cost + nbs_cost)
end

to-report co2-of [bid]
  let m mix-for bid
  if m = nobody [ report 0 ]
  let rec  table:get id-table bid
  let area item 0 rec
  let ctyp item 1 rec
  let res  item 0 m
  let nbs  item 1 m
  let cov (coverage-of-type ctyp)
  ;; RES
  let res_area (area * cov * res)
  let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
  let res_co2_m2 item 1 resI
  let res_co2 (res_area * res_co2_m2)
  ;; NBS
  let eff_nbs_area (area * cov * nbs)
  let trees (ifelse-value (tree_cover_area > 0)
               [ floor (eff_nbs_area / tree_cover_area) ]
               [ 0 ])
  if (ctyp = "roof") [
    if (tree_weight > 0) [
      let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
      if trees > load_cap [ set trees load_cap ]
    ]
  ]
  let nbs_co2 (trees * co2_reduction_NBS)
  report (res_co2 + nbs_co2)
end

to-report cost-of-any [key]
  if key = "Total" [
    if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
    ;; Use portfolio-level discounted cost (same formula as compute-portfolio-totals)
    let tot compute-portfolio-totals last-portfolio
    report item 0 tot
  ]
  report cost-of key
end

to-report co2-of-any [key]
  if key = "Total" [
    if (last-portfolio = [] or last-portfolio = nobody) [ report 0 ]
    let total 0
    foreach last-portfolio [ p -> set total total + co2-of (item 0 p) ]
    report total
  ]
  report co2-of key
end

to-report ratio-res-nbs-any [key]
  let r res-pct-of-any key
  let n nbs-pct-of-any key
  report (word (precision r 0) "%-" (precision n 0) "%")
end

to-report res-kw-of-any [key]
  report (res-area-of-any key) * res_kw_per_m2
end


to render-current-table [portfolio]
  ;; Print a table with economies-of-scale applied to row costs via portfolio-level factors
  output-print "-----------"
  output-print "ID, Area_m2, RES%, NBS%, # Trees, RES_m2, NBS_CO2_kg, NBS_Cost_€, RES_CO2_kg, RES_Cost_€, Total_CO2_kg, Total_Cost_€"
  ;; accumulators for totals and row buffering
  let sum_area 0
  let sum_trees 0
  let sum_res_area 0
  let sum_nbs_co2 0
  let sum_res_co2 0
  let sum_nbs_cost_base 0
  let sum_res_cost_base 0
  let sum_total_co2 0
  let w_sum 0
  let res_w_sum 0
  let nbs_w_sum 0
  let sum_res_units 0
  let rows []

  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p                 ;; [res nbs label]
    let res  item 0 opt
    let nbs  item 1 opt
    let rec  table:get id-table bid   ;; [area cell_type]
    let area item 0 rec
    let ctyp item 1 rec
    let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
    let res_cost_m2 item 0 resI
    let res_co2_m2  item 1 resI
    let cov (coverage-of-type ctyp)
    let eff_nbs_area (area * cov * nbs)
    let trees (ifelse-value (tree_cover_area > 0)
                 [ floor (eff_nbs_area / tree_cover_area) ]
                 [ 0 ])
    if (ctyp = "roof") [
      if (tree_weight > 0) [
        let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
        if trees > load_cap [ set trees load_cap ]
      ]
    ]
    let res_area (area * cov * res)
    let nbs_co2 (trees * co2_reduction_NBS)
    let nbs_cost0 (trees * cost_NBS)
    let res_co2 (res_area * res_co2_m2)
    let res_cost0 (res_area * res_cost_m2)
    let total_co2 (nbs_co2 + res_co2)
    ;; accumulate totals
    set sum_area (sum_area + area)
    set sum_trees (sum_trees + trees)
    set sum_res_area (sum_res_area + res_area)
    set sum_nbs_co2 (sum_nbs_co2 + nbs_co2)
    set sum_res_co2 (sum_res_co2 + res_co2)
    set sum_nbs_cost_base (sum_nbs_cost_base + nbs_cost0)
    set sum_res_cost_base (sum_res_cost_base + res_cost0)
    if (res_cell_area > 0) [ set sum_res_units (sum_res_units + floor (res_area / res_cell_area)) ]
    set sum_total_co2 (sum_total_co2 + total_co2)
    let w (area * cov)
    set w_sum (w_sum + w)
    set res_w_sum (res_w_sum + (res * w))
    set nbs_w_sum (nbs_w_sum + (nbs * w))
    set rows lput (list bid area res nbs trees res_area nbs_co2 nbs_cost0 res_co2 res_cost0 total_co2) rows
  ]

  ;; Compute portfolio-level discount factors (avoid nested reporters)
  let gR (ifelse-value (is-number? res_cost_floor) [ res_cost_floor ] [ 1.0 ])
  let NR (ifelse-value ((is-number? res_discount_units) and (res_discount_units > 0)) [ res_discount_units ] [ 1e30 ])
  let phiR min (list (sum_res_units / NR) 1)
  let res_factor (1 - (1 - gR) * phiR)
  let gN (ifelse-value (is-number? nbs_cost_floor) [ nbs_cost_floor ] [ 1.0 ])
  let NN (ifelse-value ((is-number? nbs_discount_units) and (nbs_discount_units > 0)) [ nbs_discount_units ] [ 1e30 ])
  let phiN min (list (sum_trees / NN) 1)
  let nbs_factor (1 - (1 - gN) * phiN)

  ;; Print rows with discounted per-row costs
  foreach rows [ r ->
    let bid       item 0 r
    let area      item 1 r
    let res       item 2 r
    let nbs       item 3 r
    let trees     item 4 r
    let res_area  item 5 r
    let nbs_co2   item 6 r
    let nbs_cost0 item 7 r
    let res_co2   item 8 r
    let res_cost0 item 9 r
    let total_co2 item 10 r
    let disc_nbs_cost (nbs_cost0 * nbs_factor)
    let disc_res_cost (res_cost0 * res_factor)
    let disc_total_cost (disc_nbs_cost + disc_res_cost)
    output-print (word bid ", " area ", " (precision (res * 100) 2) "% , " (precision (nbs * 100) 2) "% , "
                       trees ", "
                       (precision res_area 2) " m2, "
                       (precision nbs_co2 2) " kg, "
                       (precision disc_nbs_cost 2) " €, "
                       (precision res_co2 2) " kg, "
                       (precision disc_res_cost 2) " €, "
                       (precision total_co2 2) " kg, "
                       (precision disc_total_cost 2) " €")
  ]

  ;; Portfolio-level discounted totals (CO2 unchanged)
  let disc-total-cost ( (sum_res_cost_base * res_factor) + (sum_nbs_cost_base * nbs_factor) )
  let avg_res_pct (ifelse-value (w_sum > 0) [ (res_w_sum / w_sum) * 100 ] [ 0 ])
  let avg_nbs_pct (ifelse-value (w_sum > 0) [ (nbs_w_sum / w_sum) * 100 ] [ 0 ])
  output-print ""
  output-print (word "TOTAL (discounted), "
                     (precision sum_area 2) ", "
                     (precision avg_res_pct 2) "% , "
                     (precision avg_nbs_pct 2) "% , "
                     sum_trees ", "
                     (precision sum_res_area 2) " m2, "
                     (precision sum_nbs_co2 2) " kg, "
                     (precision (sum_nbs_cost_base * nbs_factor) 2) " €, "
                     (precision sum_res_co2 2) " kg, "
                     (precision (sum_res_cost_base * res_factor) 2) " €, "
                     (precision sum_total_co2 2) " kg, "
                     (precision disc-total-cost 2) " €")
  output-print ""
  output-print (word "Tick: " ticks "  Cost: " last-total-cost "  CO2: " last-total-co2)
end
