;; Portfolio sampler and metrics

to init-portfolio-sampler
  set blocks-ordered sort table:keys id-table
  let counts []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    if (length opts = 0) [
      user-message (word "No available options for cell type '" ctype "' after applying max_pct_RES=" max_pct_RES "% and max_pct_NBS=" max_pct_NBS "% constraints. Adjust sliders and run setup again.")
      stop
    ]
    set counts lput (length opts) counts
  ]
  set max-portfolios product-of counts
  set visited-portfolios table:make
  set initialized? true
  set combo-index 0
  print (word "Sampler ready. Max portfolios (upper bound): " max-portfolios)
end

to-report sample-portfolio
  let result []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    let choice one-of opts
    set result lput (list bid choice) result
  ]
  report result
end

to-report portfolio-key [portfolio]
  let parts []
  foreach portfolio [ p ->
    let bid   item 0 p
    let mixid item 0 (item 1 p)
    set parts lput (word bid ":" mixid) parts
  ]
  set parts sort parts
  report join-with parts "|"
end

to-report compute-portfolio-totals [portfolio]
  let total-cost 0
  let total-co2  0
  foreach portfolio [ p ->
    let bid item 0 p
    let opt item 1 p
    let res item 1 opt
    let nbs item 2 opt

    let rec table:get id-table bid
    let area item 0 rec
    let ctyp item 1 rec

    ;; RES contributions (per m2)
    let res_area (area * res)
    let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
    let res_cost_m2 item 0 resI
    let res_co2_m2  item 1 resI
    let res_cost_total (res_area * res_cost_m2)
    let res_co2_total  (res_area * res_co2_m2)

    ;; NBS contributions (per tree) with coverage cap
    let eff_nbs_area (area * (pct_covered_by_trees / 100) * nbs)
    let trees (ifelse-value (tree_cover_area > 0)
                 [ floor (eff_nbs_area / tree_cover_area) ]
                 [ 0 ])
    ;; Roof load cap: trees <= floor(eff_nbs_area * max_roof_load / tree_weight)
    if (ctyp = "roof") [
      if (tree_weight > 0) [
        let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
        if trees > load_cap [ set trees load_cap ]
      ]
    ]
    let nbs_cost_total (trees * cost_NBS)
    let nbs_co2_total  (trees * co2_reduction_NBS)

    set total-cost total-cost + res_cost_total + nbs_cost_total
    set total-co2  total-co2  + res_co2_total  + nbs_co2_total
  ]
  report (list total-cost total-co2)
end

;; -------- Deterministic enumeration --------

to-report portfolio-from-index [idx]
  ;; Mixed-radix enumeration over blocks-ordered
  let result []
  let i idx
  foreach blocks-ordered [ bid ->
    let rec   table:get id-table bid
    let ctype item 1 rec
    let opts  table:get options-by-type ctype
    let n     length opts
    let digit i mod n
    set i floor (i / n)
    let choice item digit opts
    set result lput (list bid choice) result
  ]
  report result
end

to annotate-portfolio [portfolio]
  ;; Clear existing patch labels and place a label at the center of the
  ;; merged envelope of ALL geometries for each block+cell-type key.
  ask patches [ set plabel "" ]
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p
    let lblt item 3 opt  ;; option record [mix_id res nbs label]

    let flist table:get feature-by-id bid  ;; may be a list of features
    if (flist != nobody) [
      ;; If a single feature was stored, normalize to a list
      if not is-list? flist [ set flist (list flist) ]
      if not empty? flist [
        let env0 (gis:envelope-of (first flist))
        let minx item 0 env0
        let miny item 1 env0
        let maxx item 2 env0
        let maxy item 3 env0
        foreach but-first flist [ f ->
          let el (gis:envelope-of f)
          if (item 0 el) < minx [ set minx item 0 el ]
          if (item 1 el) < miny [ set miny item 1 el ]
          if (item 2 el) > maxx [ set maxx item 2 el ]
          if (item 3 el) > maxy [ set maxy item 3 el ]
        ]
        let cx ((minx + maxx) / 2)
        let cy ((miny + maxy) / 2)
        let col (ifelse-value (table:has-key? colors-by-id bid)
                     [ table:get colors-by-id bid ]
                     [ black ])
        ask patch cx cy [
          set plabel (word "{" bid "} - " lblt)
          set plabel-color col
        ]
      ]
    ]
  ]
end

to render-current-table [portfolio]
  ;; Print a simple table of selections and areas to the output
  output-print "-----------"
  output-print "ID, Area_m2, Cell_Type, Mix_ID, RES%, NBS%, Label, # Trees, RES_m2, NBS_CO2_kg, NBS_Cost_€, RES_CO2_kg, RES_Cost_€, Total_CO2_kg, Total_Cost_€"
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p                 ;; [mix_id res nbs label]
    let mix  item 0 opt
    let res  item 1 opt
    let nbs  item 2 opt
    let lbl  item 3 opt
    let rec  table:get id-table bid   ;; [area cell_type]
    let area item 0 rec
    let ctyp item 1 rec
    ;; compute per-fragment metrics
    let resI intensity-of "RES"      ;; [cost_per_m2 co2_per_m2]
    let res_cost_m2 item 0 resI
    let res_co2_m2  item 1 resI
    let eff_nbs_area (area * (pct_covered_by_trees / 100) * nbs)
    let trees (ifelse-value (tree_cover_area > 0)
                 [ floor (eff_nbs_area / tree_cover_area) ]
                 [ 0 ])
    if (ctyp = "roof") [
      if (tree_weight > 0) [
        let load_cap floor ((eff_nbs_area * max_roof_load) / tree_weight)
        if trees > load_cap [ set trees load_cap ]
      ]
    ]
    let res_area (area * res)
    let nbs_co2 (trees * co2_reduction_NBS)
    let nbs_cost (trees * cost_NBS)
    let res_co2 (res_area * res_co2_m2)
    let res_cost (res_area * res_cost_m2)
    let total_co2 (nbs_co2 + res_co2)
    let total_cost (nbs_cost + res_cost)
    output-print (word bid ", " area ", " ctyp ", " mix ", " (precision (res * 100) 2) "% , " (precision (nbs * 100) 2) "% , " lbl ", "
                       trees ", "
                       (precision res_area 2) " m2, "
                       (precision nbs_co2 2) " kg, "
                       (precision nbs_cost 2) " €, "
                       (precision res_co2 2) " kg, "
                       (precision res_cost 2) " €, "
                       (precision total_co2 2) " kg, "
                       (precision total_cost 2) " €")
  ]
  output-print ""
  output-print (word "Tick: " ticks "  Cost: " last-total-cost "  CO2: " last-total-co2)
end
