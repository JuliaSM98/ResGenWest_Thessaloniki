;; Portfolio sampler and metrics

to init-portfolio-sampler
  set blocks-ordered sort table:keys id-table
  let counts []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    set counts lput (length opts) counts
  ]
  set max-portfolios product-of counts
  set visited-portfolios table:make
  set initialized? true
  set combo-index 0
  print (word "Sampler ready. Max portfolios (upper bound): " max-portfolios)
end

to-report sample-portfolio
  let result []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    let choice one-of opts
    set result lput (list bid choice) result
  ]
  report result
end

to-report portfolio-key [portfolio]
  let parts []
  foreach portfolio [ p ->
    let bid   item 0 p
    let mixid item 0 (item 1 p)
    set parts lput (word bid ":" mixid) parts
  ]
  set parts sort parts
  report join-with parts "|"
end

to-report compute-portfolio-totals [portfolio]
  let total-cost 0
  let total-co2  0
  foreach portfolio [ p ->
    let bid item 0 p
    let opt item 1 p
    let res item 1 opt
    let nbs item 2 opt

    let rec table:get id-table bid
    let area item 0 rec

    let res_area (area * res)
    let nbs_area (area * nbs)

    let resI intensity-of "RES"
    let nbsI intensity-of "NBS"

    let res_cost  item 0 resI
    let res_co2   item 1 resI
    let nbs_cost  item 0 nbsI
    let nbs_co2   item 1 nbsI

    set total-cost total-cost + (res_area * res_cost) + (nbs_area * nbs_cost)
    set total-co2  total-co2  + (res_area * res_co2)  + (nbs_area * nbs_co2)
  ]
  report (list total-cost total-co2)
end

;; -------- Deterministic enumeration --------

to-report portfolio-from-index [idx]
  ;; Mixed-radix enumeration over blocks-ordered
  let result []
  let i idx
  foreach blocks-ordered [ bid ->
    let rec   table:get id-table bid
    let ctype item 1 rec
    let opts  table:get options-by-type ctype
    let n     length opts
    let digit i mod n
    set i floor (i / n)
    let choice item digit opts
    set result lput (list bid choice) result
  ]
  report result
end

to annotate-portfolio [portfolio]
  ;; Clear existing patch labels and place a label at the center of the
  ;; merged envelope of ALL geometries for each block+cell-type key.
  ask patches [ set plabel "" ]
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p
    let lblt item 3 opt  ;; option record [mix_id res nbs label]

    let flist table:get feature-by-id bid  ;; may be a list of features
    if (flist != nobody) [
      ;; If a single feature was stored, normalize to a list
      if not is-list? flist [ set flist (list flist) ]
      if not empty? flist [
        let env0 (gis:envelope-of (first flist))
        let minx item 0 env0
        let miny item 1 env0
        let maxx item 2 env0
        let maxy item 3 env0
        foreach but-first flist [ f ->
          let el (gis:envelope-of f)
          if (item 0 el) < minx [ set minx item 0 el ]
          if (item 1 el) < miny [ set miny item 1 el ]
          if (item 2 el) > maxx [ set maxx item 2 el ]
          if (item 3 el) > maxy [ set maxy item 3 el ]
        ]
        let cx ((minx + maxx) / 2)
        let cy ((miny + maxy) / 2)
        let col (ifelse-value (table:has-key? colors-by-id bid)
                     [ table:get colors-by-id bid ]
                     [ black ])
        ask patch cx cy [
          set plabel (word "{" bid "} - " lblt)
          set plabel-color col
        ]
      ]
    ]
  ]
end

to render-current-table [portfolio]
  ;; Print a simple table of selections and areas to the output
  output-print "-----------"
  output-print "ID, Area_m2, Cell_Type, Mix_ID, RES%, NBS%, Label, CO2_kg/m2, Cost_€/m2, CO2_kg, Cost_€"
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p                 ;; [mix_id res nbs label]
    let mix  item 0 opt
    let res  item 1 opt
    let nbs  item 2 opt
    let lbl  item 3 opt
    let rec  table:get id-table bid   ;; [area cell_type]
    let area item 0 rec
    let ctyp item 1 rec
    ;; compute combined intensities and totals
    let resI intensity-of "RES"
    let nbsI intensity-of "NBS"
    let res_cost  item 0 resI
    let res_co2   item 1 resI
    let nbs_cost  item 0 nbsI
    let nbs_co2   item 1 nbsI
    let co2_per_m2  ((res * res_co2) + (nbs * nbs_co2))
    let cost_per_m2 ((res * res_cost) + (nbs * nbs_cost))
    let co2_total (co2_per_m2 * area)
    let cost_total (cost_per_m2 * area)
    output-print (word bid ", " area ", " ctyp ", " mix ", " (precision (res * 100) 2) "% , " (precision (nbs * 100) 2) "% , " lbl ", "
                       (precision co2_per_m2 4) " kg/m2, "
                       (precision cost_per_m2 4) " €/m2, "
                       (precision co2_total 2) " kg, "
                       (precision cost_total 2) " €")
  ]
  output-print ""
  output-print (word "Tick: " ticks "  Cost: " last-total-cost "  CO2: " last-total-co2)
end
