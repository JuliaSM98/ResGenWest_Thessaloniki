;; Portfolio sampler and metrics

to init-portfolio-sampler
  set blocks-ordered sort table:keys id-table
  let counts []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    set counts lput (length opts) counts
  ]
  set max-portfolios product-of counts
  set visited-portfolios table:make
  set initialized? true
  set combo-index 0
  print (word "Sampler ready. Max portfolios (upper bound): " max-portfolios)
end

to-report sample-portfolio
  let result []
  foreach blocks-ordered [ bid ->
    let rec table:get id-table bid
    let ctype item 1 rec
    let opts table:get options-by-type ctype
    let choice one-of opts
    set result lput (list bid choice) result
  ]
  report result
end

to-report portfolio-key [portfolio]
  let parts []
  foreach portfolio [ p ->
    let bid   item 0 p
    let mixid item 0 (item 1 p)
    set parts lput (word bid ":" mixid) parts
  ]
  set parts sort parts
  report join-with parts "|"
end

to-report compute-portfolio-totals [portfolio]
  let total-cost 0
  let total-co2  0
  foreach portfolio [ p ->
    let bid item 0 p
    let opt item 1 p
    let res item 1 opt
    let nbs item 2 opt

    let rec table:get id-table bid
    let area item 0 rec

    let res_area (area * res)
    let nbs_area (area * nbs)

    let resI intensity-of "RES"
    let nbsI intensity-of "NBS"

    let res_cost  item 0 resI
    let res_co2   item 1 resI
    let nbs_cost  item 0 nbsI
    let nbs_co2   item 1 nbsI

    set total-cost total-cost + (res_area * res_cost) + (nbs_area * nbs_cost)
    set total-co2  total-co2  + (res_area * res_co2)  + (nbs_area * nbs_co2)
  ]
  report (list total-cost total-co2)
end

;; -------- Deterministic enumeration --------

to-report portfolio-from-index [idx]
  ;; Mixed-radix enumeration over blocks-ordered
  let result []
  let i idx
  foreach blocks-ordered [ bid ->
    let rec   table:get id-table bid
    let ctype item 1 rec
    let opts  table:get options-by-type ctype
    let n     length opts
    let digit i mod n
    set i floor (i / n)
    let choice item digit opts
    set result lput (list bid choice) result
  ]
  report result
end

to annotate-portfolio [portfolio]
  ;; Clear existing patch labels and set each polygon's label at its envelope center patch
  ask patches [ set plabel "" ]
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p
    let lblt item 3 opt  ;; option record [mix_id res nbs label]
    let f table:get feature-by-id bid
    let env gis:envelope-of f  ;; [minx miny maxx maxy]
    let cx ( (item 0 env + item 2 env) / 2 )
    let cy ( (item 1 env + item 3 env) / 2 )
    let col (ifelse-value (table:has-key? colors-by-id bid)
                [ table:get colors-by-id bid ]
                [ black ])
    ask patch cx cy [
      set plabel (word "{" bid "} - " lblt)
      set plabel-color col
    ]
  ]
end

to render-current-table [portfolio]
  ;; Print a simple table of selections and areas to the output
  clear-output
  output-print "ID, Area_m2, Cell_Type, Mix_ID, RES%, NBS%, Label"
  foreach portfolio [ p ->
    let bid  item 0 p
    let opt  item 1 p                 ;; [mix_id res nbs label]
    let mix  item 0 opt
    let res  item 1 opt
    let nbs  item 2 opt
    let lbl  item 3 opt
    let rec  table:get id-table bid   ;; [area cell_type]
    let area item 0 rec
    let ctyp item 1 rec
    output-print (word bid ", " area ", " ctyp ", " mix ", " (precision (res * 100) 2) "% , " (precision (nbs * 100) 2) "% , " lbl)
  ]
  output-print ""
  output-print (word "Tick: " ticks "  Cost: " last-total-cost "  CO2: " last-total-co2)
end
