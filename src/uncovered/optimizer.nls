;; Python optimizer integration and plotting (shared across projects)

to-report outputs-base-dir
  ;; Prefer model-defined outputs_base if present, else default to data/outputs
  if (is-string? outputs_base and (length outputs_base > 0)) [ report outputs_base ]
  report "data/outputs"
end

to-report join-path [base name]
  report (word base "/" name)
end

to-report filename-of [p]
  if not is-string? p [ report "out.csv" ]
  let s p
  let sep "/"
  let pos position sep s
  while [ pos != false ] [
    set s substring s (pos + 1) (length s)
    set pos position sep s
  ]
  report s
end

to run-optimizer-and-plot [python-exe uncovered-dir options-csv out-csv budget-mode budget-steps]
  ;; Require setup to be run first (consistent with schools model)
  if (not is-boolean? initialized?) or (initialized? = false) [
    user-message "Please click setup first to load data and initialize."
    stop
  ]
  ;; Resolve effective paths even if user didn't run setup
  let unco (ifelse-value (is-string? uncovered-dir and (length uncovered-dir > 0))
               [ uncovered-dir ]
               [ shapefile-path ])
  if (not is-string? unco) or (length unco = 0) [
    user-message "Please set shapefile-path in the Code tab (and click setup) before running the optimizer."
    stop
  ]
  let optp (ifelse-value (is-string? options-csv and (length options-csv > 0))
               [ options-csv ]
               [ ifelse-value (is-string? options-csv-path and (length options-csv-path > 0))
                   [ options-csv-path ]
                   [ "data/csv/options.csv" ] ])

  ;; Determine effective steps (prefer slider, else button arg, else 41)
  let bs (ifelse-value (is-number? budget_steps)
             [ budget_steps ]
             [ ifelse-value (is-number? budget-steps) [ budget-steps ] [ 41 ] ])

  ;; Debug prints: show both the slider and the computed steps
  print (word "Effective budget-steps=" bs)

  ;; build project-specific output paths
  let base outputs-base-dir
  let argsf (join-path base "optimizer_args.txt")
  let outcsv (join-path base (filename-of out-csv))
  ;; write optimizer args from sliders so the script can pick them up and override defaults
  write-optimizer-args "data/outputs/optimizer_args.txt" unco optp budget-mode bs out-csv
  ;; Execute wrapper script (it reads args from data/outputs/optimizer_args.txt)
  let cmd "scripts/run_optimizer.sh"
  print (word "Running script: " cmd " with uncovered=" unco " options=" optp " steps=" bs)
  let _out shell:exec cmd
  if _out != "" [ print _out ]

  ;; Plot results
  plot-optimizer-results outcsv "Cost vs CO2 (Python)"
end

;; Single-solve: maximize CO2 under a budget (uses budget-max slider)
to run-optimizer-under-budget-and-plot [python-exe uncovered-dir options-csv out-csv]
  ;; Require setup to be run first
  if (not is-boolean? initialized?) or (initialized? = false) [
    user-message "Please click setup first to load data and initialize."
    stop
  ]
  let unco (ifelse-value (is-string? uncovered-dir and (length uncovered-dir > 0))
               [ uncovered-dir ]
               [ shapefile-path ])
  if (not is-string? unco) or (length unco = 0) [
    user-message "Please set shapefile-path in the Code tab (and click setup) before running the optimizer."
    stop
  ]
  let optp (ifelse-value (is-string? options-csv and (length options-csv > 0))
               [ options-csv ]
               [ ifelse-value (is-string? options-csv-path and (length options-csv-path > 0))
                   [ options-csv-path ]
                   [ "data/csv/options.csv" ] ])
  ;; project-specific outputs
  let base outputs-base-dir
  let outcsv (join-path base (filename-of out-csv))
  ;; write args for single solve
  write-optimizer-budget-args "data/outputs/optimizer_args.txt" unco optp outcsv budget-max
  let cmd "scripts/run_optimizer.sh"
  print (word "Running single-solve under budget: " budget-max)
  let _out shell:exec cmd
  if _out != "" [ print _out ]
  ;; adopt or show popup if not found
  adopt-or-popup (join-path base "solve_under_budget_selections.csv") (word "budget=" budget-max)
end

;; Single-solve: minimize cost subject to CO2 >= co2-min slider
to run-optimizer-above-co2-and-save [python-exe uncovered-dir options-csv out-csv]
  ;; Require setup to be run first
  if (not is-boolean? initialized?) or (initialized? = false) [
    user-message "Please click setup first to load data and initialize."
    stop
  ]
  ;; Resolve effective paths even if user didn't run setup
  let unco (ifelse-value (is-string? uncovered-dir and (length uncovered-dir > 0))
               [ uncovered-dir ]
               [ shapefile-path ])
  if (not is-string? unco) or (length unco = 0) [
    user-message "Please set shapefile-path in the Code tab (and click setup) before running the optimizer."
    stop
  ]
  let optp (ifelse-value (is-string? options-csv and (length options-csv > 0))
               [ options-csv ]
               [ ifelse-value (is-string? options-csv-path and (length options-csv-path > 0))
                   [ options-csv-path ]
                   [ "data/csv/options.csv" ] ])
  file-close-all
  let base outputs-base-dir
  let argsf "data/outputs/optimizer_args.txt"
  if file-exists? argsf [ file-delete argsf ]
  file-open argsf
  file-print (word "--uncovered-dir=" unco)
  file-print (word "--options=" optp)
  file-print (word "--out=" (join-path base (filename-of out-csv)))
  file-print (word "--mode=min-cost-above-co2")
  if is-number? co2-min [ file-print (word "--co2-min=" co2-min) ]
  file-print (word "--portfolios-out=" (join-path base "solve_above_co2.json"))
  file-print (word "--selections-out=" (join-path base "solve_above_co2_selections.csv"))
  file-print (word "--table-out=" (join-path base "solve_above_co2_table.csv"))
  file-print (word "--cost-res=" cost_RES)
  file-print (word "--co2-res=" co2_reduction_RES)
  file-print (word "--cost-nbs=" cost_NBS)
  file-print (word "--co2-nbs=" co2_reduction_NBS)
  file-print (word "--pct-covered-by-NBS-RES=" pct_covered_by_NBS_RES)
  file-print (word "--tree-cover-area=" tree_cover_area)
  if is-number? tree_weight [ file-print (word "--tree-weight=" tree_weight) ]
  if is-number? max_roof_load [ file-print (word "--max-roof-load=" max_roof_load) ]
  file-print (word "--max-pct-res=" max_pct_RES)
  file-print (word "--max-pct-nbs=" max_pct_NBS)
  file-close
  let cmd "scripts/run_optimizer.sh"
  print (word "Running single-solve with CO2 >= " co2-min)
  let _out shell:exec cmd
  if _out != "" [ print _out ]
  adopt-or-popup (join-path base "solve_above_co2_selections.csv") (word "CO2 >= " co2-min)
end

;; Single-solve: both constraints â€” maximize CO2 with cost<=budget-max and CO2>=co2-min
to run-optimizer-both-constraints [python-exe uncovered-dir options-csv out-csv]
  ;; Require setup to be run first
  if (not is-boolean? initialized?) or (initialized? = false) [
    user-message "Please click setup first to load data and initialize."
    stop
  ]
  ;; Resolve effective paths even if user didn't run setup
  let unco (ifelse-value (is-string? uncovered-dir and (length uncovered-dir > 0))
               [ uncovered-dir ]
               [ shapefile-path ])
  if (not is-string? unco) or (length unco = 0) [
    user-message "Please set shapefile-path in the Code tab (and click setup) before running the optimizer."
    stop
  ]
  let optp (ifelse-value (is-string? options-csv and (length options-csv > 0))
               [ options-csv ]
               [ ifelse-value (is-string? options-csv-path and (length options-csv-path > 0))
                   [ options-csv-path ]
                   [ "data/csv/options.csv" ] ])
  file-close-all
  let base outputs-base-dir
  let argsf "data/outputs/optimizer_args.txt"
  if file-exists? argsf [ file-delete argsf ]
  file-open argsf
  file-print (word "--uncovered-dir=" unco)
  file-print (word "--options=" optp)
  file-print (word "--out=" (join-path base (filename-of out-csv)))
  file-print (word "--mode=both-constraints")
  if is-number? budget-max [ file-print (word "--budget-max=" budget-max) ]
  if is-number? co2-min [ file-print (word "--co2-min=" co2-min) ]
  file-print (word "--portfolios-out=" (join-path base "solve_both_constraints.json"))
  file-print (word "--selections-out=" (join-path base "solve_both_constraints_selections.csv"))
  file-print (word "--table-out=" (join-path base "solve_both_constraints_table.csv"))
  file-print (word "--cost-res=" cost_RES)
  file-print (word "--co2-res=" co2_reduction_RES)
  file-print (word "--cost-nbs=" cost_NBS)
  file-print (word "--co2-nbs=" co2_reduction_NBS)
  file-print (word "--pct-covered-by-NBS-RES=" pct_covered_by_NBS_RES)
  file-print (word "--tree-cover-area=" tree_cover_area)
  file-print (word "--max-pct-res=" max_pct_RES)
  file-print (word "--max-pct-nbs=" max_pct_NBS)
  file-close
  let cmd "scripts/run_optimizer.sh"
  print (word "Running both-constraints with budget=" budget-max " and CO2 >= " co2-min)
  let _out shell:exec cmd
  if _out != "" [ print _out ]
  adopt-or-popup (join-path base "solve_both_constraints_selections.csv") (word "budget=" budget-max ", CO2 >= " co2-min)
end

to adopt-or-popup [sel-path mode-msg]
  if not file-exists? sel-path [
    user-message (word "No feasible solution found (" mode-msg "). Try adjusting limits or parameters.")
    stop
  ]
  file-close-all
  file-open sel-path
  if file-at-end? [ file-close user-message (word "No feasible solution found (" mode-msg ").") stop ]
  let _hdr csv:from-row file-read-line
  if file-at-end? [ file-close user-message (word "No feasible solution found (" mode-msg ").") stop ]
  file-close
  adopt-selection-from-selections sel-path
  print (word "Optimization finished (" mode-msg ")  Total Cost=" last-total-cost "  Total CO2=" last-total-co2)
end

to write-optimizer-budget-args [path uncovered-dir options-csv out-csv budget_max_value]
  file-close-all
  if file-exists? path [ file-delete path ]
  file-open path
  file-print (word "--uncovered-dir=" uncovered-dir)
  file-print (word "--options=" options-csv)
  file-print (word "--out=" out-csv)
  file-print (word "--mode=max-co2-under-budget")
  ;; also persist metadata JSON for the chosen solution
  let base outputs-base-dir
  file-print (word "--portfolios-out=" (join-path base "solve_under_budget.json"))
  file-print (word "--selections-out=" (join-path base "solve_under_budget_selections.csv"))
  ;; write detailed table CSV for the chosen solution
  file-print (word "--table-out=" (join-path base "solve_under_budget_table.csv"))
  if is-number? budget_max_value [ file-print (word "--budget-max=" budget_max_value) ]
  file-print (word "--cost-res=" cost_RES)
  file-print (word "--co2-res=" co2_reduction_RES)
  file-print (word "--cost-nbs=" cost_NBS)
  file-print (word "--co2-nbs=" co2_reduction_NBS)
  file-print (word "--pct-covered-by-NBS-RES=" pct_covered_by_NBS_RES)
  file-print (word "--tree-cover-area=" tree_cover_area)
  if is-number? tree_weight [ file-print (word "--tree-weight=" tree_weight) ]
  if is-number? max_roof_load [ file-print (word "--max-roof-load=" max_roof_load) ]
  file-print (word "--max-pct-res=" max_pct_RES)
  file-print (word "--max-pct-nbs=" max_pct_NBS)
  file-close
end

to adopt-selection-from-selections [path]
  ;; Ensure data tables are initialized (safe even if setup was already run)
  if (not is-boolean? initialized?) [ setup ]
  if initialized? = false [ setup ]
  if not file-exists? path [ stop ]
  file-close-all
  file-open path
  print (word "Adopting selection from " path)
  if file-at-end? [ file-close stop ]
  let _header csv:from-row file-read-line
  let portfolio []
  while [ not file-at-end? ] [
    let line file-read-line
    if length line > 0 [
      let row csv:from-row line
      let rawid item 4 row
      let resp  item 6 row
      let nbsp  item 7 row
      let bid (word rawid)
      if not table:has-key? id-table bid [
        set bid (resolve-key-by-type bid)
      ]
      let opt (list (as-number resp) (as-number nbsp) "")
      set portfolio lput (list bid opt) portfolio
    ]
  ]
  file-close
  set last-portfolio portfolio
  let tot compute-portfolio-totals portfolio
  set last-total-cost item 0 tot
  set last-total-co2  item 1 tot
end

;; Resolve a raw block id to an id-table key, preferring :roof or :ground when present.
to-report resolve-key-by-type [raw]
  let k (word raw)
  if (id-table = nobody) [ report k ]
  if table:has-key? id-table k [ report k ]
  ;; Try explicit suffixes first (prefer :roof for rooftops models)
  if table:has-key? id-table (word k ":roof") [ report (word k ":roof") ]
  if table:has-key? id-table (word k ":ground") [ report (word k ":ground") ]
  ;; Normalize pattern "X.Block_N" -> "X.N" and try again
  let tag ".Block_"
  let pos position tag k
  if pos != false [
    let left_elem substring k 0 pos
    let right_elem substring k (pos + length tag) (length k)
    let base (word left_elem "." right_elem)
    if table:has-key? id-table (word base ":roof")   [ report (word base ":roof") ]
    if table:has-key? id-table (word base ":ground") [ report (word base ":ground") ]
    if table:has-key? id-table base [ report base ]
  ]
  report k
end

to write-optimizer-args [path uncovered-dir options-csv budget-mode budget-steps out-csv]
  file-close-all
  if file-exists? path [ file-delete path ]
  file-open path
  ;; Write one CLI token per line in --flag=value form for safe reading in shell
  file-print (word "--uncovered-dir=" uncovered-dir)
  file-print (word "--options=" options-csv)
  file-print (word "--out=" out-csv)
  ;; Determine step count from slider or param (no budget-mode flag)
  let bs (ifelse-value (is-number? budget_steps)
             [ budget_steps ]
             [ ifelse-value (is-number? budget-steps) [ budget-steps ] [ 41 ] ])
  file-print (word "--budget-steps=" bs)
  file-print (word "--cost-res=" cost_RES)
  file-print (word "--co2-res=" co2_reduction_RES)
  file-print (word "--cost-nbs=" cost_NBS)
  file-print (word "--co2-nbs=" co2_reduction_NBS)
  file-print (word "--pct-covered-by-NBS-RES=" pct_covered_by_NBS_RES)
  file-print (word "--tree-cover-area=" tree_cover_area)
  if is-number? tree_weight [ file-print (word "--tree-weight=" tree_weight) ]
  if is-number? max_roof_load [ file-print (word "--max-roof-load=" max_roof_load) ]
  file-print (word "--max-pct-res=" max_pct_RES)
  file-print (word "--max-pct-nbs=" max_pct_NBS)
  file-close
end

to plot-optimizer-results [csv-path plot-name_elem]
  if not file-exists? csv-path [
    user-message (word "Results CSV not found: " csv-path)
    stop
  ]
  set-current-plot plot-name_elem
  clear-plot
  ;; ensure we plot points, not lines
  if not plot-pen-exists? "points" [ create-temporary-plot-pen "points" ]
  set-current-plot-pen "points"
  set-plot-pen-mode 2  ;; points
  file-close-all
  file-open csv-path
  if file-at-end? [ file-close stop ]
  ;; consume header
  let _header csv:from-row file-read-line
  while [ not file-at-end? ] [
    let line file-read-line
    if length line > 0 [
      let row csv:from-row line
      ;; Expect: cost,co2,n_blocks; items may already be numbers
      let cost item 0 row
      let co2  item 1 row
      if not is-number? cost [ set cost read-from-string cost ]
      if not is-number? co2  [ set co2  read-from-string co2  ]
      plotxy cost co2
    ]
  ]
  file-close
end
